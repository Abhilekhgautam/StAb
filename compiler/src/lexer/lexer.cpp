
/* %% [0.0] Make hook macros available to Flex */
/* A lexical scanner generated by flex */

/* Target: C/C++ */
/* START of m4 controls */
/* M4_YY_TABLES_VERIFY = 0 */
/* M4_MODE_NO_DO_STDINIT */
/* M4_MODE_NO_YYTEXT_IS_ARRAY */
/* M4_MODE_NO_YYMORE_USED */
/* M4_MODE_NO_REAL_FULLSPD */
/* M4_MODE_NO_REAL_FULLTBL */
/* M4_MODE_NO_CPP_USE_READ */
/* M4_MODE_NO_VARIABLE_TRAILING_CONTEXT_RULES */
/* M4_MODE_FIND_ACTION_REJECT_REALLY_USED */
/* M4_MODE_NO_USES_REJECT */
/* M4_MODE_USEMECS */
/* M4_MODE_FIND_ACTION_COMPRESSED */
/* M4_MODE_NO_FULLSPD */
/* M4_MODE_NO_BOL_NEEDED */
/* M4_MODE_USEECS */
/* M4_MODE_GENTABLES */
/* M4_MODE_INTERACTIVE */
/* M4_MODE_NO_FULLSPD_OR_FULLTBL */
/* M4_MODE_FIND_ACTION_REJECT_OR_INTERACTIVE */
/* M4_MODE_YYCLASS */
/* M4_MODE_DEBUG */
/* M4_MODE_NO_YYWRAP */
/* M4_MODE_INTERACTIVE */
/* M4_MODE_CXX_ONLY */
/* M4_MODE_PREFIX = yy_stab_ */
/* M4_MODE_NO_REWRITE */
/* END of m4 controls */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

    /* The c++ scanner is a mess. The FlexLexer.h header file relies on the
     * following macro. This is required in order to pass the c++-multiple-scanners
     * test in the regression suite. We get reports that it breaks inheritance.
     * We will address this in a future release of flex, or omit the C++ scanner
     * altogether.
     */
    #define yyFlexLexer yy_stab_FlexLexer

#ifdef yyalloc
#define yy_stab_alloc_ALREADY_DEFINED
#else
#define yyalloc yy_stab_alloc
#endif

#ifdef yyrealloc
#define yy_stab_realloc_ALREADY_DEFINED
#else
#define yyrealloc yy_stab_realloc
#endif

#ifdef yyfree
#define yy_stab_free_ALREADY_DEFINED
#else
#define yyfree yy_stab_free
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */

/* end standard C headers. */

/* begin standard C++ headers. */

#include <iostream>
#include <errno.h>
#include <cstdlib>
#include <cstdio>
#include <cstring>
/* end standard C++ headers. */

/* flex integer type definitions */

#ifndef YYFLEX_INTTYPES_DEFINED
#define YYFLEX_INTTYPES_DEFINED

/* Prefer C99 integer types if available. */

# if defined(__cplusplus) && __cplusplus >= 201103L
#include <cstdint>
#  define YYFLEX_USE_STDINT
# endif
# if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
/* Include <inttypes.h> and not <stdint.h> because Solaris 2.6 has the former
 * and not the latter.
 */
#include <inttypes.h>
#  define YYFLEX_USE_STDINT
# else
#  if defined(_MSC_VER) && _MSC_VER >= 1600
/* Visual C++ 2010 does not define __STDC_VERSION__ and has <stdint.h> but not
 * <inttypes.h>.
 */
#include <stdint.h>
#   define YYFLEX_USE_STDINT
#  endif
# endif
# ifdef YYFLEX_USE_STDINT
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
# else
typedef unsigned char flex_uint8_t;
typedef short int flex_int16_t;
typedef unsigned short int flex_uint16_t;
#  ifdef __STDC__
typedef signed char flex_int8_t;
/* ISO C only requires at least 16 bits for int. */
#   ifdef __cplusplus
#include <climits>
#   else
#include <limits.h>
#   endif
#   if UINT_MAX >= 4294967295
#    define YYFLEX_INT32_DEFINED
typedef int flex_int32_t;
typedef unsigned int flex_uint32_t;
#   endif
#  else
typedef char flex_int8_t;
#  endif
#  ifndef YYFLEX_INT32_DEFINED
typedef long int flex_int32_t;
typedef unsigned long int flex_uint32_t;
#  endif
# endif
#endif /* YYFLEX_INTTYPES_DEFINED */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR) (c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define yybegin(s) (yy_start) = 1 + 2 * (s)
/* Legacy interface */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define yystart() (((yy_start) - 1) / 2)
/* Legacy interfaces */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin  )
#define YY_END_OF_BUFFER_CHAR 0

/* The state buf must be large enough to hold one state per character in the main buffer,
 * plus the start state, plus the two end-of-buffer byte states.
 */
#define YY_STATE_BUF_EXTRA_SPACE 3
#define YY_STATE_BUF_SIZE   (YY_BUF_SIZE + YY_STATE_BUF_EXTRA_SPACE)

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *yybuffer;
/* Legacy interface */
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2
    
    #define YY_LESS_LINENO(n)
    #define YY_LINENO_REWIND_TO(ptr)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
#define yyunput(c) yyunput_r( c, (yytext_ptr)  )
/* Legacy interface */
#define unput(c) yyunput_r( c, (yytext_ptr)  )

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{

	std::streambuf* yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yyatbol;

	int yy_bs_lineno; /**< The line count. */
	int yy_bs_column; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define yy_current_buffer() ( (yy_buffer_stack)			\
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)
/* Legacy interface */
#define YY_CURRENT_BUFFER yy_current_buffer()
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) { \
	if ( yy_current_buffer() == NULL ) { \
		yyensure_buffer_stack ();	\
		YY_CURRENT_BUFFER_LVALUE =    \
			yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}
#define yysetbol(at_bol) \
	{ \
	if ( yy_current_buffer() == NULL ) { \
		yyensure_buffer_stack ();	\
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yyatbol = at_bol; \
}
#define yyatbol() (YY_CURRENT_BUFFER_LVALUE->yyatbol)
/* Legacy interface */
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yyatbol)
#define yy_set_bol(at_bol) \
	{ \
	if ( yy_current_buffer() == NULL ) { \
		yyensure_buffer_stack ();	\
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yyatbol = at_bol; \
}

/* Begin user sect3 */

#define YY_SKIP_YYWRAP

#define FLEX_DEBUG

typedef flex_uint8_t YY_CHAR;

#define yytext_ptr yytext
#define YY_INTERACTIVE

#include <FlexLexer.h>

int yyFlexLexer::yywrap() { return 1;}

int yyFlexLexer::yylex()
	{
	LexerError( "yyFlexLexer::yylex invoked but %option yyclass used" );
	return 0;
	}

#define YY_DECL int Lexer::yylex()

/* %% [1.5] DFA */
/* %% [1.5] DFA */
/* START of m4 controls */
/* M4_MODE_NO_NULTRANS */
/* M4_MODE_NO_NULTRANS_FULLTBL */
/* M4_MODE_NO_NULTRANS_FULLSPD */
/* END of m4 controls */

/* START of Flex-generated definitions */
#define YY_NUM_RULES 49
#define YY_END_OF_BUFFER 50
#define YY_JAMBASE 136
#define YY_JAMSTATE 111
#define YY_NUL_EC 1
#define YY_OFFSET_TYPE flex_int16_t
/* END of Flex-generated definitions */

struct yy_trans_info
	{
	/* We require that yy_verify and yy_nxt must be of the same size int. */

	/* We generate a bogus 'struct yy_trans_info' data type
	 * so we can guarantee that it is always declared in the skel.
	 * This is so we can compile "sizeof(struct yy_trans_info)"
	 * in any scanner.
	 */
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;

	};

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	do { \
	(yytext_ptr) = yy_bp; \
	 \
	yyleng = (int) (yy_cp - yy_bp); \
	 \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
 \
	(yy_c_buf_p) = yy_cp; \
	} while(0)

/* %% [2.0] data tables for the DFA are inserted here */
/* %% [2.0] data tables for the DFA are inserted here */

/* footprint: 11761 bytes */
/* tblend: 184 */
/* numecs: 48 */
/* num_rules: 49 */
/* lastdfa: 110 */

/* m4 controls begin */
/* M4_MODE_HAS_BACKING_UP */
/* M4_MODE_NEED_YY_CP */
/* m4 controls end */

static const flex_int16_t yy_accept[112] = { 0,
         0,    0,   50,   49,    1,    4,   49,   49,   35,   36,
        37,   33,   31,    7,   32,   34,    2,    5,   42,   47,
        44,   30,   40,   41,   30,   30,   30,   30,   30,   30,
        30,   30,   30,   30,   30,   30,   30,   30,   38,   39,
         1,   48,    0,   29,    0,    6,    3,    2,   43,   46,
         8,   45,   30,   30,   30,   30,    9,   30,   10,   30,
        18,   30,   30,   21,   30,   30,   30,   28,   30,   30,
        30,    0,    3,   20,   30,   30,   14,   30,   17,   30,
        30,   30,   30,   30,   30,   30,   22,    0,   30,   11,
        30,   13,   30,   30,   24,   30,   26,   30,   23,    0,

        30,   16,   30,   30,   15,    0,   19,   25,   27,   12,
         0
};

/* Character equivalence-class mapping */
static const YY_CHAR yy_ec[256] = { 0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    4,    5,    6,    1,    1,    7,    1,    1,    8,
         9,   10,   11,   12,   13,    1,   14,   15,   15,   15,
        15,   15,   15,   15,   15,   15,   15,    1,   16,   17,
        18,   19,    1,    1,   20,   20,   20,   20,   20,   20,
        20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
        20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
        21,   22,   23,    1,   24,    1,   25,   26,   27,   28,

        29,   30,   31,   32,   33,   20,   34,   35,   36,   37,
        38,   39,   20,   40,   41,   42,   43,   44,   45,   46,
        20,   20,   47,    1,   48,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1
};

/* Character meta-equivalence-class mappings */
static const YY_CHAR yy_meta[49] = { 0,
         1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    3,    1,    1,    1,    1,    3,
         1,    1,    1,    3,    3,    3,    3,    3,    3,    3,
         3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
         3,    3,    3,    3,    3,    3,    1,    1
};

static const flex_int16_t yy_base[117] = { 0,
         0,    0,  135,  136,   47,  136,  116,   44,  136,  136,
       136,  136,  136,  136,  114,  118,  116,  136,  112,   34,
       111,    0,  136,  136,   91,   87,   91,   17,   26,   87,
        99,   83,   93,   23,   83,   82,   87,   80,  136,  136,
        56,  136,   53,  136,    0,  136,    0,  102,  136,  136,
       136,  136,    0,   88,   86,   73,    0,   73,    0,   73,
        69,   72,   67,    0,   66,   74,   66,    0,   72,   71,
        63,   55,    0,    0,   77,   72,    0,   62,    0,   60,
        71,   54,   57,   62,   66,   58,    0,   58,   54,   81,
        39,    0,   46,   36,    0,   37,    0,   44,    0,   39,

        29,    0,   33,   38,    0,   38,    0,    0,    0,  136,
       136,   80,   64,   83,   86,   89
};

static const flex_int16_t yy_def[117] = { 0,
       111,    1,  111,  111,  111,  111,  111,  112,  111,  111,
       111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
       111,  113,  111,  111,  113,  113,  113,  113,  113,  113,
       113,  113,  113,  113,  113,  113,  113,  113,  111,  111,
       111,  111,  112,  111,  114,  111,  115,  111,  111,  111,
       111,  111,  113,  113,  113,  113,  113,  113,  113,  113,
       113,  113,  113,  113,  113,  113,  113,  113,  113,  113,
       113,  116,  115,  113,  113,  113,  113,  113,  113,  113,
       113,  113,  113,  113,  113,  113,  113,  116,  113,  113,
       113,  113,  113,  113,  113,  113,  113,  113,  113,  111,

       113,  113,  113,  113,  113,  111,  113,  113,  113,  111,
         0,  111,  111,  111,  111,  111
};

static const flex_int16_t yy_nxt[185] = { 0,
         4,    5,    6,    5,    7,    8,    9,   10,   11,   12,
        13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
        23,    4,   24,    4,   25,   26,   22,   22,   27,   28,
        22,   22,   29,   22,   30,   31,   22,   32,   22,   33,
        34,   35,   22,   36,   37,   38,   39,   40,   41,   44,
        41,   50,   51,   57,   58,   59,   66,   41,   44,   41,
        44,   60,   61,   44,   67,   45,   53,  110,  109,  108,
       107,  106,  105,  104,   45,  103,   45,  102,  101,   45,
        43,   43,   43,   72,  100,   72,   73,   99,   73,   88,
        88,   88,   98,   97,   96,   95,   94,   93,   92,   91,

        90,   89,   87,   86,   85,   84,   83,   82,   81,   80,
        79,   78,   77,   76,   75,   74,   48,   71,   70,   69,
        68,   65,   64,   63,   62,   56,   55,   54,   52,   49,
        48,   47,   46,   42,  111,    3,  111,  111,  111,  111,
       111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
       111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
       111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
       111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
       111,  111,  111,  111
};

static const flex_int16_t yy_chk[185] = { 0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    5,    8,
         5,   20,   20,   28,   28,   29,   34,   41,   43,   41,
        72,   29,   29,   88,   34,    8,  113,  106,  104,  103,
       101,  100,   98,   96,   43,   94,   72,   93,   91,   88,
       112,  112,  112,  114,   90,  114,  115,   89,  115,  116,
       116,  116,   86,   85,   84,   83,   82,   81,   80,   78,

        76,   75,   71,   70,   69,   67,   66,   65,   63,   62,
        61,   60,   58,   56,   55,   54,   48,   38,   37,   36,
        35,   33,   32,   31,   30,   27,   26,   25,   21,   19,
        17,   16,   15,    7,    3,  111,  111,  111,  111,  111,
       111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
       111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
       111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
       111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
       111,  111,  111,  111
};

/* Rule to line-number mapping */
static const flex_int16_t yy_rule_linenum[49] = { 0,
        27,   28,   33,   34,   36,   40,   44,   48,   52,   56,
        60,   64,   68,   72,   76,   78,   80,   85,   87,   89,
        91,   93,   95,   97,   99,  101,  107,  113,  115,  121,
       127,  133,  139,  144,  149,  154,  156,  158,  160,  162,
       164,  166,  171,  176,  182,  188,  193,  195
};

/* The intent behind this definition is that it'll catch
 * any uses of yyreject() which flex missed.
 */
#define yyreject() reject_used_but_not_detected
#define REJECT reject_used_but_not_detected

#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET

/* %% [3.0] static declarations conditional on mode switches go here */
/* %% [3.0] static declarations conditional on mode switches go here */
#line 1 "src/lexer/lexer.l"
#line 2 "src/lexer/lexer.l"
  #include "lexer.hpp"
  #include <cstring>
  using namespace STAB;

  #undef YY_DECL
  #define YY_DECL int Lexer::yylex(STAB::Parser::value_type* lval, location* const lloc)
  #define YY_USER_INIT yylval = lval; yyloc = lloc;
  #define YY_USER_ACTION copyLocation();
#line 593 "src/lexer/lexer.cpp"
#line 22 "src/lexer/lexer.l"
  using Token = STAB::Parser::token;
  using location = STAB::location;
#line 597 "src/lexer/lexer.cpp"
#line 598 "src/lexer/lexer.cpp"

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */

#include <unistd.h>

#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_YYINPUT

#endif

/*
 * Amount of stuff to slurp up with each read.
 * We assume the stdio library has already
 * chosen a fit size foe whatever platform
 * we're running on.
 */
#define YY_READ_BUF_SIZE BUFSIZ

/* Size of default input buffer. We want to be able to fit two
 * OS-level reads, but efficiency gains as the buffer size
 * increases fall off after that
 */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE	(2 * YY_READ_BUF_SIZE)
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef yyecho

#define yyecho() LexerOutput( yytext, yyleng )

#endif
/* Legacy interface */
#define ECHO yyecho()

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

void yyFlexLexer::LexerError( const char* msg ) {
		std::cerr << msg << std::endl;
	exit( YY_EXIT_FAILURE );
}

/* Report a fatal error. Legacy interface. */
#ifndef YY_FATAL_ERROR

#define YY_FATAL_ERROR(msg) LexerError( msg )

#endif

/* Legacy interface */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) do {result = yyread(buf, max_size );} while (0)

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */

int yyFlexLexer::yyread(char *buf, size_t max_size) {

	int result;
	
	if ( (int)(result = LexerInput( (char *) buf, max_size )) < 0 ) {
		YY_FATAL_ERROR( "input in flex scanner failed" );
	}

	 return result;
}
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

#define YY_DECL int yyFlexLexer::yylex()

#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

#define YY_RULE_SETUP \
		YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL {
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    
	if ( !(yy_init) ) {
		(yy_init) = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! (yy_start) ) {
			(yy_start) = 1;	/* first start state */
		}
		if ( ! yyin ) {

			yyin.rdbuf(std::cin.rdbuf());

		}
		if ( ! yyout ) {

			yyout.rdbuf(std::cout.rdbuf());

		}
		if ( yy_current_buffer() == NULL ) {
			yyensure_buffer_stack ();
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer( yyin, YY_BUF_SIZE );
		}

		yy_load_buffer_state(  );
	}

	/* open scope of user declarationns */
	{
/* %% [4.0] user's declarations go here */
/* %% [4.0] user's declarations go here */
#line 26 "src/lexer/lexer.l"

#line 764 "src/lexer/lexer.cpp"

		while ( /*CONSTCOND*/1 ) {		/* loops until end-of-file is reached */

			yy_cp = (yy_c_buf_p);

			/* Support of yytext. */
			*yy_cp = (yy_hold_char);

			/* yy_bp points to the position in yy_ch_buf of the start of
			 * the current run.
			 */
			yy_bp = yy_cp;

	/* Generate the code to find the start state. */

			yy_current_state = (yy_start);

			/* Set up for storing up states. */
			
	yy_match:
			/* Generate the code to find the next match. */

			do {
				
	int yy_c = *(yy_ec+YY_SC_TO_UI(*yy_cp));
	/* Save the backing-up info \before/ computing the next state
	 * because we always compute one more state than needed - we
	 * always proceed until we reach a jam state
	 */
	
		/* Generate code to keep backing-up information. */

		if ( yy_accept[yy_current_state] ) {

			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
		}

	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) {
		yy_current_state = (int) yy_def[yy_current_state];

		/* We've arranged it so that templates are never chained
		 * to one another.  This means we can afford to make a
		 * very simple test to see if we need to convert to
		 * yy_c's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
		 */

		/* lastdfa + 2 == YY_JAMSTATE + 1 is the beginning of the templates */
		if (yy_current_state >= YY_JAMSTATE + 1) {
			yy_c = yy_meta[yy_c];
		}

	}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];

				++yy_cp;

			}
			while ( yy_base[yy_current_state] != YY_JAMBASE );
			
	yy_find_action:
			/* code to find the action number goes here */
			
		yy_act = yy_accept[yy_current_state];
			if ( yy_act == 0 ) { /* have to back up */
				yy_cp = (yy_last_accepting_cpos);
				yy_current_state = (yy_last_accepting_state);
				yy_act = yy_accept[yy_current_state];
			}

			YY_DO_BEFORE_ACTION;

		do_action:	/* This label is used only to access EOF actions. */

			if ( yyflexdebug ) {
				if ( yy_act == 0 ) {

					std::cerr << "--scanner backing up\n";

				} else if ( yy_act < YY_NUM_RULES ) {

					std::cerr << "--accepting rule at line " << yy_rule_linenum[yy_act] <<
						"(\"" << yytext << "\")\n";

				} else if ( yy_act == YY_NUM_RULES ) {

					std::cerr << "--accepting default rule (\"" << yytext << "\")\n";

     				} else if ( yy_act == YY_NUM_RULES + 1 ) {

					std::cerr << "--(end of buffer or a NUL)\n";

				} else {

					std::cerr << "--EOF (start condition " << yystart() << ")\n";

				}
			}

			switch ( yy_act ) { /* beginning of action switch */

			case 0: /* must back up */
				/* undo the effects of YY_DO_BEFORE_ACTION */
				*yy_cp = (yy_hold_char);

				/* Backing-up info for compressed tables is taken \after/ */
				/* yy_cp has been incremented for the next state. */
				yy_cp = (yy_last_accepting_cpos);
				
				yy_current_state = (yy_last_accepting_state);
				goto yy_find_action;

/* %% [5.0] user actions get inserted here */
/* %% [5.0] user actions get inserted here */
	case 1:
YY_RULE_SETUP

#line 27 "src/lexer/lexer.l"
{/* do nothing; ignore */step(strlen(yytext));}
	/*LINTED*/break;
	case 2:
YY_RULE_SETUP

#line 28 "src/lexer/lexer.l"
{
  yylval->emplace<std::string>(yytext);
  step(strlen(yytext));
  return Token::token_kind_type::NUMBER;
}
	/*LINTED*/break;
	case 3:
YY_RULE_SETUP

#line 33 "src/lexer/lexer.l"
/* eat up the entire line */
	/*LINTED*/break;
	case 4:
/* rule 4 can match eol */
YY_RULE_SETUP

#line 34 "src/lexer/lexer.l"
{++currentLine; currentColumn = 1;}
	/*LINTED*/break;
	case 5:
YY_RULE_SETUP

#line 36 "src/lexer/lexer.l"
{
     step();
     return Token::token_kind_type::SEMI_COLON;
    }
	/*LINTED*/break;
	case 6:
YY_RULE_SETUP

#line 40 "src/lexer/lexer.l"
{
      step(2);
      return Token::token_kind_type::FN_ARROW;
     }
	/*LINTED*/break;
	case 7:
YY_RULE_SETUP

#line 44 "src/lexer/lexer.l"
{
     step();
     return Token::token_kind_type::COMMA;
    }
	/*LINTED*/break;
	case 8:
YY_RULE_SETUP

#line 48 "src/lexer/lexer.l"
{
      step(2);
      return Token::token_kind_type::MATCH_ARROW;
     }
	/*LINTED*/break;
	case 9:
YY_RULE_SETUP

#line 52 "src/lexer/lexer.l"
{
     step(2);
     return Token::token_kind_type::FN;
     }
	/*LINTED*/break;
	case 10:
YY_RULE_SETUP

#line 56 "src/lexer/lexer.l"
{
     step(2);
     return Token::token_kind_type::IF;
     }
	/*LINTED*/break;
	case 11:
YY_RULE_SETUP

#line 60 "src/lexer/lexer.l"
{
        step(4);
        return Token::token_kind_type::ELSE;
        }
	/*LINTED*/break;
	case 12:
YY_RULE_SETUP

#line 64 "src/lexer/lexer.l"
{
            step(6);
            return Token::token_kind_type::ELSE_IF;
           }
	/*LINTED*/break;
	case 13:
YY_RULE_SETUP

#line 68 "src/lexer/lexer.l"
{
        step(4);
        return Token::token_kind_type::LOOP;
       }
	/*LINTED*/break;
	case 14:
YY_RULE_SETUP

#line 72 "src/lexer/lexer.l"
{ step(3);
        return Token::token_kind_type::FOR;
      }
	/*LINTED*/break;
	case 15:
YY_RULE_SETUP

#line 76 "src/lexer/lexer.l"
{ step(5);return Token::token_kind_type::WHILE;}
	/*LINTED*/break;
	case 16:
YY_RULE_SETUP

#line 78 "src/lexer/lexer.l"
{step(5); return Token::token_kind_type::MATCH;}
	/*LINTED*/break;
	case 17:
YY_RULE_SETUP

#line 80 "src/lexer/lexer.l"
{
       yylval->emplace<std::string>(yytext);
       step(3);
       return Token::token_kind_type::DATA_TYPE;
      }
	/*LINTED*/break;
	case 18:
YY_RULE_SETUP

#line 85 "src/lexer/lexer.l"
{ step(2); return Token::token_kind_type::IN;}
	/*LINTED*/break;
	case 19:
YY_RULE_SETUP

#line 87 "src/lexer/lexer.l"
{ step(6); return Token::token_kind_type::IMPORT;}
	/*LINTED*/break;
	case 20:
YY_RULE_SETUP

#line 89 "src/lexer/lexer.l"
{ step(3); return Token::token_kind_type::AND;}
	/*LINTED*/break;
	case 21:
YY_RULE_SETUP

#line 91 "src/lexer/lexer.l"
{ step(2); return Token::token_kind_type::OR;}
	/*LINTED*/break;
	case 22:
YY_RULE_SETUP

#line 93 "src/lexer/lexer.l"
{ step(3);return Token::token_kind_type::XOR;}
	/*LINTED*/break;
	case 23:
YY_RULE_SETUP

#line 95 "src/lexer/lexer.l"
{ step(5); return Token::token_kind_type::BREAK;}
	/*LINTED*/break;
	case 24:
YY_RULE_SETUP

#line 97 "src/lexer/lexer.l"
{ step(5); return Token::token_kind_type::SKIP;}
	/*LINTED*/break;
	case 25:
YY_RULE_SETUP

#line 99 "src/lexer/lexer.l"
{ step(6); return Token::token_kind_type::RETURN;}
	/*LINTED*/break;
	case 26:
YY_RULE_SETUP

#line 101 "src/lexer/lexer.l"
{
         yylval->emplace<std::string>(yytext);
	 step(4);
	 return Token::token_kind_type::DATA_TYPE;
       }
	/*LINTED*/break;
	case 27:
YY_RULE_SETUP

#line 107 "src/lexer/lexer.l"
{
          yylval->emplace<std::string>(yytext);
	  step(6);
	  return Token::token_kind_type::DATA_TYPE;
         }
	/*LINTED*/break;
	case 28:
YY_RULE_SETUP

#line 113 "src/lexer/lexer.l"
{ step(2); return Token::token_kind_type::TO;}
	/*LINTED*/break;
	case 29:
/* rule 29 can match eol */
YY_RULE_SETUP

#line 115 "src/lexer/lexer.l"
{
        yylval->emplace<std::string>(yytext);
	step(strlen(yytext));
        return Token::token_kind_type::STRING;
     }
	/*LINTED*/break;
	case 30:
YY_RULE_SETUP

#line 121 "src/lexer/lexer.l"
{
       yylval->emplace<std::string>(yytext);
       step(strlen(yytext));
       return Token::token_kind_type::ID;
    }
	/*LINTED*/break;
	case 31:
YY_RULE_SETUP

#line 127 "src/lexer/lexer.l"
{
    yylval->emplace<std::string>(yytext);
    step();
    return Token::token_kind_type::PLUS;
    }
	/*LINTED*/break;
	case 32:
YY_RULE_SETUP

#line 133 "src/lexer/lexer.l"
{
    yylval->emplace<std::string>(yytext);
    step();
    return Token::token_kind_type::MINUS;
    }
	/*LINTED*/break;
	case 33:
YY_RULE_SETUP

#line 139 "src/lexer/lexer.l"
{
     yylval->emplace<std::string>(yytext);
     step();
     return Token::token_kind_type::TIMES;
    }
	/*LINTED*/break;
	case 34:
YY_RULE_SETUP

#line 144 "src/lexer/lexer.l"
{
     yylval->emplace<std::string>(yytext);
     step();
     return Token::token_kind_type::DIV;
    }
	/*LINTED*/break;
	case 35:
YY_RULE_SETUP

#line 149 "src/lexer/lexer.l"
{
     yylval->emplace<std::string>(yytext);
     step();
     return Token::token_kind_type::MOD;
     }
	/*LINTED*/break;
	case 36:
YY_RULE_SETUP

#line 154 "src/lexer/lexer.l"
{ step(); return Token::token_kind_type::LBRACE;}
	/*LINTED*/break;
	case 37:
YY_RULE_SETUP

#line 156 "src/lexer/lexer.l"
{ step(); return Token::token_kind_type::RBRACE;}
	/*LINTED*/break;
	case 38:
YY_RULE_SETUP

#line 158 "src/lexer/lexer.l"
{ step(); return Token::token_kind_type::LCURLY;}
	/*LINTED*/break;
	case 39:
YY_RULE_SETUP

#line 160 "src/lexer/lexer.l"
{ step(); return Token::token_kind_type::RCURLY;}
	/*LINTED*/break;
	case 40:
YY_RULE_SETUP

#line 162 "src/lexer/lexer.l"
{ step(); return Token::token_kind_type::LBIG;}
	/*LINTED*/break;
	case 41:
YY_RULE_SETUP

#line 164 "src/lexer/lexer.l"
{ step(); return Token::token_kind_type::RBIG;}
	/*LINTED*/break;
	case 42:
YY_RULE_SETUP

#line 166 "src/lexer/lexer.l"
{
     yylval->emplace<std::string>(yytext);
     step(strlen(yytext));
     return Token::token_kind_type::LT;
    }
	/*LINTED*/break;
	case 43:
YY_RULE_SETUP

#line 171 "src/lexer/lexer.l"
{
      yylval->emplace<std::string>("l");
      step(2);
      return Token::token_kind_type::LE;
     }
	/*LINTED*/break;
	case 44:
YY_RULE_SETUP

#line 176 "src/lexer/lexer.l"
{
      yylval->emplace<std::string>(yytext);
      step();
      return Token::token_kind_type::GT;
    }
	/*LINTED*/break;
	case 45:
YY_RULE_SETUP

#line 182 "src/lexer/lexer.l"
{
      yylval->emplace<std::string>("g");
      step(2);
     return Token::token_kind_type::GE;
     }
	/*LINTED*/break;
	case 46:
YY_RULE_SETUP

#line 188 "src/lexer/lexer.l"
{
      yylval->emplace<std::string>("e");
      step(2);
      return Token::token_kind_type::EQ;
     }
	/*LINTED*/break;
	case 47:
YY_RULE_SETUP

#line 193 "src/lexer/lexer.l"
{ step(); return Token::token_kind_type::ASSIGN;}
	/*LINTED*/break;
	case 48:
YY_RULE_SETUP

#line 195 "src/lexer/lexer.l"
{
      yylval->emplace<std::string>("n");
      step(2);
      return  Token::token_kind_type::NE;
     }
	/*LINTED*/break;
	case 49:
YY_RULE_SETUP

#line 200 "src/lexer/lexer.l"
yyecho();
	/*LINTED*/break;
#line 1274 "src/lexer/lexer.cpp"
#line 1275 "src/lexer/lexer.cpp"
	case YY_STATE_EOF(INITIAL):
		/* FALLTHROUGH */
		yyterminate();

			case YY_END_OF_BUFFER:
			{
				/* Amount of text matched not including the EOB char. */
				int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

				/* Undo the effects of YY_DO_BEFORE_ACTION. */
				*yy_cp = (yy_hold_char);
				YY_RESTORE_YY_MORE_OFFSET

				if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW ) {
					/* We're scanning a new file or input source.  It's
					 * possible that this happened because the user
					 * just pointed yyin at a new source and called
					 * yylex().  If so, then we have to assure
					 * consistency between yy_current_buffer() and our
					 * globals.  Here is the right place to do so, because
					 * this is the first action (other than possibly a
					 * back-up) that will match for the new input source.
					 */
					(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;

					YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin.rdbuf();

					YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
				}

				/* Note that here we test for yy_c_buf_p "<=" to the position
				 * of the first EOB in the buffer, since yy_c_buf_p will
				 * already have been incremented past the NUL character
				 * (since all states make transitions on EOB to the
				 * end-of-buffer state).  Contrast this with the test
				 * in input().
				 */
				if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] ) { /* This was really a NUL. */
					yy_state_type yy_next_state;

					(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

					yy_current_state = yy_get_previous_state(  );

					/* Okay, we're now positioned to make the NUL
					 * transition.  We couldn't have
					 * yy_get_previous_state() go ahead and do it
					 * for us because it doesn't know how to deal
					 * with the possibility of jamming (and we don't
					 * want to build jamming into it because then it
					 * will run more slowly).
					 */

					yy_next_state = yy_try_NUL_trans( yy_current_state );

					yy_bp = (yytext_ptr) + YY_MORE_ADJ;

					if ( yy_next_state ) {
						/* Consume the NUL. */
						yy_cp = ++(yy_c_buf_p);
						yy_current_state = yy_next_state;
						goto yy_match;
					} else {
						
						/* Still need to initialize yy_cp, though
						 * yy_current_state was set up by
						 * yy_get_previous_state().
						 */
						yy_cp = (yy_c_buf_p);

						goto yy_find_action;
					}
				} else {	/* not a NUL */
					switch ( yy_get_next_buffer(  ) ) {
					case EOB_ACT_END_OF_FILE:
						(yy_did_buffer_switch_on_eof) = 0;

						if ( yywrap(  ) ) {
							/* Note: because we've taken care in
							 * yy_get_next_buffer() to have set up
							 * yytext, we can now set up
							 * yy_c_buf_p so that if some total
							 * hoser (like flex itself) wants to
							 * call the scanner after we return the
							 * YY_NULL, it'll still work - another
							 * YY_NULL will get returned.
							 */
							(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

							yy_act = YY_STATE_EOF(yystart());
							goto do_action;
						} else {
							if ( ! (yy_did_buffer_switch_on_eof) ) {
								YY_NEW_FILE;
							}
						}
						break;
					case EOB_ACT_CONTINUE_SCAN:
						(yy_c_buf_p) =
							(yytext_ptr) + yy_amount_of_matched_text;

						yy_current_state = yy_get_previous_state(  );

						yy_cp = (yy_c_buf_p);
						yy_bp = (yytext_ptr) + YY_MORE_ADJ;
						goto yy_match;

					case EOB_ACT_LAST_MATCH:
						(yy_c_buf_p) =
						&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

						yy_current_state = yy_get_previous_state(  );

						yy_cp = (yy_c_buf_p);
						yy_bp = (yytext_ptr) + YY_MORE_ADJ;
						goto yy_find_action;
					} /* end EOB inner switch */
				} /* end if */
				break;
			} /* case YY_END_OF_BUFFER */
			default:
				YY_FATAL_ERROR("fatal flex scanner internal error--no action found" );
			} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yylex */

/* The contents of this function are C++ specific, so the () macro is not used.
 * This constructor simply maintains backward compatibility.
 * DEPRECATED
 */
yyFlexLexer::yyFlexLexer( std::istream* arg_yyin, std::ostream* arg_yyout ):
	yyin(arg_yyin ? arg_yyin->rdbuf() : std::cin.rdbuf()),
	yyout(arg_yyout ? arg_yyout->rdbuf() : std::cout.rdbuf())
{
	ctor_common();
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
yyFlexLexer::yyFlexLexer( std::istream& arg_yyin, std::ostream& arg_yyout ):
	yyin(arg_yyin.rdbuf()),
	yyout(arg_yyout.rdbuf())
{
	ctor_common();
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
void yyFlexLexer::ctor_common() {
	yy_c_buf_p = 0;
	yy_init = 0;
	yy_start = 0;
	yyflexdebug = 0;
	yylineno = 1;	// this will only get updated if %option yylineno

	yy_did_buffer_switch_on_eof = 0;

	yy_looking_for_trail_begin = 0;
	yy_more_flag = 0;
	yy_more_len = 0;
	yy_more_offset = yy_prev_more_offset = 0;

	yy_start_stack_ptr = yy_start_stack_depth = 0;
	yy_start_stack = NULL;

	yy_buffer_stack = NULL;
	yy_buffer_stack_top = 0;
	yy_buffer_stack_max = 0;

	yy_state_buf = 0;

}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
yyFlexLexer::~yyFlexLexer() {
	delete [] yy_state_buf;
	yyfree( yy_start_stack  );
	yy_delete_buffer( yy_current_buffer() );
	yyfree( yy_buffer_stack  );
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
void yyFlexLexer::switch_streams( std::istream& new_in, std::ostream& new_out ) {
	// was if( new_in )
	yy_delete_buffer( YY_CURRENT_BUFFER );
	yy_switch_to_buffer( yy_create_buffer( new_in, YY_BUF_SIZE  ) );

	// was if( new_out )
	yyout.rdbuf(new_out.rdbuf());
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
void yyFlexLexer::switch_streams( std::istream* new_in, std::ostream* new_out )
{
	if( ! new_in ) {
		new_in = &yyin;
	}

	if ( ! new_out ) {
		new_out = &yyout;
	}

	switch_streams(*new_in, *new_out);
}

#ifdef YY_INTERACTIVE
int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )
#else
int yyFlexLexer::LexerInput( char* buf, int max_size )
#endif
{
	if ( yyin.eof() || yyin.fail() ) {
		return 0;
	}
#ifdef YY_INTERACTIVE
	yyin.get( buf[0] );

	if ( yyin.eof() ) {
		return 0;
	}
	if ( yyin.bad() ) {
		return -1;
	}
	return 1;

#else
	(void) yyin.read( buf, max_size );

	if ( yyin.bad() ) {
		return -1;
	} else {
		return (int)yyin.gcount();
	}
#endif
}

void yyFlexLexer::LexerOutput( const char* buf, int size ) {
	(void) yyout.write( buf, size );
}

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

int yyFlexLexer::yy_get_next_buffer()

{
		char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = (yytext_ptr);
	int number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] ) {
		YY_FATAL_ERROR( "fatal flex scanner internal error--end of buffer missed" );
	}
	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 ) {
		/* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 ) {
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
		} else {
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
		}
	}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);

	for ( i = 0; i < number_to_move; ++i ) {
		*(dest++) = *(source++);
	}
	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING ) {
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
	} else {
		int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 ) { /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			yybuffer b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) ((yy_c_buf_p) - b->yy_ch_buf);

			if ( b->yy_is_our_buffer ) {
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 ) {
					b->yy_buf_size += b->yy_buf_size / 8;
				} else {
					b->yy_buf_size *= 2;
				}
				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc( (void *) b->yy_ch_buf,
							 (yy_size_t) (b->yy_buf_size + 2)  );
			} else {
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;
			}
			if ( ! b->yy_ch_buf ) {
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );
			}
			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

		}

		if ( num_to_read > YY_READ_BUF_SIZE ) {
			num_to_read = YY_READ_BUF_SIZE;
		}
		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			(yy_n_chars), num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
	}

	if ( (yy_n_chars) == 0 ) {
		if ( number_to_move == YY_MORE_ADJ ) {
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin  );
		} else {
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
		}
	} else {
		ret_val = EOB_ACT_CONTINUE_SCAN;
	}
	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf ) {
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
		}
		/* "- 2" to take care of EOB's */
		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

yy_state_type yyFlexLexer::yy_get_previous_state()

{
	yy_state_type yy_current_state;
	char *yy_cp;
	
	/* Generate the code to find the start state. */

			yy_current_state = (yy_start);

			/* Set up for storing up states. */
			
	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp ) {
		/* Generate the code to find the next state. */
		
	int yy_c = (*yy_cp ? *(yy_ec+YY_SC_TO_UI(*yy_cp)) : YY_NUL_EC);
	/* Save the backing-up info \before/ computing the next state
	 * because we always compute one more state than needed - we
	 * always proceed until we reach a jam state
	 */
	
		/* Generate code to keep backing-up information. */

		if ( yy_accept[yy_current_state] ) {

			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
		}

	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) {
		yy_current_state = (int) yy_def[yy_current_state];

		/* We've arranged it so that templates are never chained
		 * to one another.  This means we can afford to make a
		 * very simple test to see if we need to convert to
		 * yy_c's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
		 */

		/* lastdfa + 2 == YY_JAMSTATE + 1 is the beginning of the templates */
		if (yy_current_state >= YY_JAMSTATE + 1) {
			yy_c = yy_meta[yy_c];
		}

	}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];

	}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */

yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )

{
	int yy_is_jam;
		/* Generate code for handling NUL's, if needed. */

	/* First, deal with backing up and setting up yy_cp if the scanner
	 * finds that it should JAM on the NUL.
	 *
	 * Only generate a definition for "yy_cp" if we'll generate code
	 * that uses it.  Otherwise lint and the like complain.
	 */
	char *yy_cp = (yy_c_buf_p);

	int yy_c = YY_NUL_EC;
	/* Save the backing-up info \before/ computing the next state
	 * because we always compute one more state than needed - we
	 * always proceed until we reach a jam state
	 */
	
		/* Generate code to keep backing-up information. */

		if ( yy_accept[yy_current_state] ) {

			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
		}

	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) {
		yy_current_state = (int) yy_def[yy_current_state];

		/* We've arranged it so that templates are never chained
		 * to one another.  This means we can afford to make a
		 * very simple test to see if we need to convert to
		 * yy_c's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
		 */

		/* lastdfa + 2 == YY_JAMSTATE + 1 is the beginning of the templates */
		if (yy_current_state >= YY_JAMSTATE + 1) {
			yy_c = yy_meta[yy_c];
		}

	}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];

yy_is_jam = (yy_current_state == YY_JAMSTATE);

		return yy_is_jam ? 0 : yy_current_state;
}

void yyFlexLexer::yyunput_r( int c, char* yy_bp)

{
	char *yy_cp;
	
	yy_cp = (yy_c_buf_p);

	/* undo effects of setting up yytext */
	*yy_cp = (yy_hold_char);

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 ) {
		/* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = (yy_n_chars) + 2;
		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf ) {
			*--dest = *--source;
		}
		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 ) {
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}
	}

	*--yy_cp = (char) c;

	(yytext_ptr) = yy_bp;
	(yy_hold_char) = *yy_cp;
	(yy_c_buf_p) = yy_cp;
}

int yyFlexLexer::yyinput()

{
	int c;
	
	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR ) {
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] ) {
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';
		} else {
			/* need more input */
			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) ) {
			case EOB_ACT_LAST_MATCH:
				/* This happens because yy_g_n_b()
				 * sees that we've accumulated a
				 * token and flags that we need to
				 * try matching the token before
				 * proceeding.  But for input(),
				 * there's no matching to consider.
				 * So convert the EOB_ACT_LAST_MATCH
				 * to EOB_ACT_END_OF_FILE.
				 */

				/* Reset buffer status. */
				yyrestart( yyin );

				/*FALLTHROUGH*/

			case EOB_ACT_END_OF_FILE:
				if ( yywrap(  ) ) {
					return 0;
				}
				if ( ! (yy_did_buffer_switch_on_eof) ) {
					YY_NEW_FILE;
				}
				return yyinput();

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) = (yytext_ptr) + offset;
				break;
			}
		}
	}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	return c;
}

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */

void yyFlexLexer::yyrestart( std::istream& input_file )

{
	
	if ( yy_current_buffer() == NULL ) {
		yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
	        	yy_create_buffer( yyin, YY_BUF_SIZE );
	}

	yy_init_buffer( YY_CURRENT_BUFFER_LVALUE, input_file );
	yy_load_buffer_state(  );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Delegate to the new version that takes an istream reference.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyFlexLexer::yyrestart( std::istream* input_file )
{
	if( ! input_file ) {
		input_file = &yyin;
	}
	yyrestart( *input_file );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */

void yyFlexLexer::yy_switch_to_buffer( yybuffer new_buffer )

{
	
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
	 */
	yyensure_buffer_stack ();
	if ( yy_current_buffer() == new_buffer ) {
		return;
	}
	if ( yy_current_buffer() ) {
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
	}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state(  );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

void yyFlexLexer::yy_load_buffer_state()

{
		(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;

	yyin.rdbuf(YY_CURRENT_BUFFER_LVALUE->yy_input_file);

	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */

yybuffer yyFlexLexer::yy_create_buffer( std::istream& file, int size )

{
	yybuffer b;

	b = (yybuffer) yyalloc( sizeof( struct yy_buffer_state )  );
	if (  b == NULL ) {
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
	}
	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
	if ( b->yy_ch_buf == NULL ) {
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
	}
	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
}

/** Delegate creation of buffers to the new version that takes an istream reference.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
yybuffer yyFlexLexer::yy_create_buffer( std::istream* file, int size )
{
	return yy_create_buffer( *file, size );
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * 
 */

void yyFlexLexer::yy_delete_buffer( yybuffer b )

{
	
	if ( b == NULL ) {
		return;
	}
	if ( b == yy_current_buffer() ) {	/* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (yybuffer) 0;
	}
	if ( b->yy_is_our_buffer ) {
		yyfree( (void *) b->yy_ch_buf  );
	}
	yyfree( (void *) b  );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */

void yyFlexLexer::yy_init_buffer( yybuffer b, std::istream& file )

{
	int oerrno = errno;
	
	yy_flush_buffer( b );

	b->yy_input_file = file.rdbuf();

    /* b->yy_input_file should never by NULL but we'll handle it cleanly
	 * on the off chance.
	 */
	if (b->yy_input_file == NULL){
	  b->yy_fill_buffer = 0;
	} else {
	  b->yy_fill_buffer = 1;
	}

	/* If b is the current buffer, then yy_init_buffer was _probably_
	 * called from yyrestart() or through yy_get_next_buffer.
	 * In that case, we don't want to reset the lineno or column.
	 */
	if (b != yy_current_buffer()) {
		b->yy_bs_lineno = 1;
		b->yy_bs_column = 0;
	}

	b->yy_is_interactive = 0;

	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c yy_current_buffer().
 * 
 */

void yyFlexLexer::yy_flush_buffer( yybuffer b )

{
		if ( b == NULL ) {
		return;
	}
	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yyatbol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == yy_current_buffer() ) {
		yy_load_buffer_state(  );
	}
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */

void yyFlexLexer::yypush_buffer_state (yybuffer new_buffer)

{
		if (new_buffer == NULL) {
		return;
	}
	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( yy_current_buffer() != NULL ) {
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
	}

	/* Only push if top exists. Otherwise, replace top. */
	if (yy_current_buffer()) {
		(yy_buffer_stack_top)++;
	}
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state(  );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */

void yyFlexLexer::yypop_buffer_state (void)

{
		if (yy_current_buffer() == NULL) {
		return;
	}
	yy_delete_buffer(yy_current_buffer() );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) > 0) {
		--(yy_buffer_stack_top);
	}
	if (yy_current_buffer() != NULL) {
		yy_load_buffer_state(  );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */

void yyFlexLexer::yyensure_buffer_stack(void)

{
	yy_size_t num_to_alloc;
	
	if ((yy_buffer_stack) == NULL) {
		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
		 */
		num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( (yy_buffer_stack == NULL) ) {
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
		}

		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1) {
		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ((yy_buffer_stack) == NULL) {
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
		}
		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

void yyFlexLexer::yy_push_state( int _new_state )

{
		if ( (yy_start_stack_ptr) >= (yy_start_stack_depth) ) {
		yy_size_t new_size;

		(yy_start_stack_depth) += YY_START_STACK_INCR;
		new_size = (yy_size_t) (yy_start_stack_depth) * sizeof( int );

		if ( ! (yy_start_stack) ) {
			(yy_start_stack) = (int *) yyalloc( new_size  );

		} else {
			(yy_start_stack) = (int *) yyrealloc(
					(void *) (yy_start_stack), new_size  );
		}
		if ( ! (yy_start_stack) ) {
			YY_FATAL_ERROR( "out of memory expanding start-condition stack" );
		}
	}
	(yy_start_stack)[(yy_start_stack_ptr)++] = yystart();

	yybegin(_new_state);
}

void yyFlexLexer::yy_pop_state()

{
		if ( --(yy_start_stack_ptr) < 0 ) {
		YY_FATAL_ERROR( "start-condition stack underflow" );
	}
	yybegin((yy_start_stack)[(yy_start_stack_ptr)]);
}

int yyFlexLexer::yy_top_state()

{
		return (yy_start_stack_ptr) > 0 ? (yy_start_stack)[(yy_start_stack_ptr) - 1] : yystart();
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do { \
		/* Undo effects of setting up yytext. */ \
		int yyless_macro_arg = (n); \
		YY_LESS_LINENO(yyless_macro_arg);\
			yytext[yyleng] = (yy_hold_char); \
			(yy_c_buf_p) = yytext + yyless_macro_arg; \
			(yy_hold_char) = *(yy_c_buf_p); \
			*(yy_c_buf_p) = '\0'; \
			yyleng = yyless_macro_arg; \
	} while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, const char * s2, int n ) {
		
	int i;
	for ( i = 0; i < n; ++i ) {
		s1[i] = s2[i];
	}
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (const char * s )
{
	int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size ) {
			return malloc(size);
}

void *yyrealloc  (void * ptr, yy_size_t  size ) {
		
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return realloc(ptr, size);
}

void yyfree (void * ptr ) {
			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#line 200 "src/lexer/lexer.l"


